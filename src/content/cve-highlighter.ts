import { CONFIG, NAVIGATION_EVENT } from './constants';
import { isVulnersHostname } from './utils';
import { TooltipManager } from './tooltip-manager';
import { DOMScanner } from './dom-scanner';

export class CVEHighlighter {
  private tooltipManager: TooltipManager;
  private domScanner: DOMScanner;

  private enabled = true;
  private isProcessing = false;
  private needsRescan = false;
  private mutationDebounceTimeout: number = NaN;
  private mutationDebounceMs: number = CONFIG.MUTATION_DEBOUNCE_MS;
  private navigationSettleTimeout: number = NaN;
  private pauseUntilMs = 0;
  private burstScanToken = 0;

  constructor() {
    this.tooltipManager = new TooltipManager();
    this.domScanner = new DOMScanner(this.tooltipManager);
    this.waitForPageLoad();
  }

  private waitForPageLoad(): void {
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        this.init();
      });
    } else {
      // DOM is ready or page is fully loaded - start immediately
      this.init();
    }
  }

  private isVulnersSite(): boolean {
    return isVulnersHostname(window.location.hostname);
  }

  private observeNavigation(): void {
    const handleNavigation = () => {
      this.bumpNavigationSettle();
    };

    // Navigation API (experimental) for SPA navigations
    const navigation = (window as unknown as { navigation?: EventTarget })
      .navigation;
    if (navigation && typeof navigation.addEventListener === 'function') {
      navigation.addEventListener('navigate', handleNavigation);
      navigation.addEventListener('currententrychange', handleNavigation);
    }

    // Fallback signals
    window.addEventListener('popstate', handleNavigation);
    window.addEventListener('hashchange', handleNavigation);
    window.addEventListener(NAVIGATION_EVENT, handleNavigation);

    // Patch history methods in page context to detect pushState/replaceState
    this.installHistoryHook();
  }

  private installHistoryHook(): void {
    if (
      document.documentElement?.querySelector(
        'script[data-vulners-history-hook="true"]'
      )
    ) {
      return;
    }

    const script = document.createElement('script');
    script.setAttribute('data-vulners-history-hook', 'true');
    script.src = chrome.runtime.getURL('history-hook.js');

    try {
      (document.documentElement || document.head || document.body).appendChild(
        script
      );
    } catch {
      // CSP may block script injection - fall back to MutationObserver-only detection
    }
  }

  private async init(): Promise<void> {
    const settings = await chrome.storage.local.get(['enabled']);
    this.enabled = settings.enabled !== false;

    // Don't highlight on vulners.com domain
    if (this.isVulnersSite()) {
      this.enabled = false;
    }

    if (this.enabled) {
      await this.domScanner.loadPatterns();

      // Set up observers first so we catch all changes
      this.observeNavigation();
      this.observePageChanges();
      this.settleForDelay(CONFIG.INITIAL_SETTLE_DELAY_MS);
    }

    chrome.runtime.onMessage.addListener((request, _sender, sendResponse) => {
      if (request.action === 'toggleHighlighting') {
        // Don't allow enabling on vulners.com
        if (this.isVulnersSite()) {
          this.enabled = false;
        } else {
          this.enabled = request.enabled;
        }

        if (this.enabled) {
          if (!this.domScanner.isPatternsLoaded()) {
            this.domScanner.loadPatterns().then(() => this.scanAndHighlight());
          } else {
            this.scanAndHighlight();
          }
        } else {
          this.domScanner.removeAllHighlights();
        }
      } else if (request.action === 'getStats') {
        sendResponse({
          count: this.domScanner.getHighlightedBulletins().size,
          typeCounts: this.domScanner.getBulletinTypeCounts(),
        });
      }
    });
  }

  private setupPeriodicScan(): void {
    // Fast rescanning for dynamically loaded content
    const scanToken = ++this.burstScanToken;
    let scanCount = 0;
    let currentInterval: number = CONFIG.INITIAL_SCAN_INTERVAL_MS;

    const scheduleNextScan = () => {
      if (scanToken !== this.burstScanToken) {
        return;
      }
      if (scanCount >= CONFIG.MAX_SCAN_ATTEMPTS || !this.enabled) {
        return;
      }

      setTimeout(() => {
        if (scanToken !== this.burstScanToken) {
          return;
        }
        scanCount++;

        if (!this.enabled) {
          return;
        }

        const previousCount = this.domScanner.getHighlightedBulletins().size;
        console.log(
          `Vulners: Fast rescan ${scanCount}/${CONFIG.MAX_SCAN_ATTEMPTS} (found: ${previousCount})`
        );

        this.scanAndHighlight();

        const newCount = this.domScanner.getHighlightedBulletins().size;

        if (newCount > previousCount) {
          // Found new CVEs, keep scanning quickly
          currentInterval = Math.min(
            currentInterval,
            CONFIG.INITIAL_SCAN_INTERVAL_MS
          );
        } else if (newCount >= CONFIG.MIN_CVES_FOR_SLOWDOWN) {
          // Found plenty of CVEs, slow down
          currentInterval = CONFIG.MAX_SCAN_INTERVAL_MS;
        } else {
          // No new CVEs found, gradually slow down
          currentInterval = Math.min(
            currentInterval * CONFIG.SCAN_INTERVAL_MULTIPLIER,
            CONFIG.MAX_SCAN_INTERVAL_MS
          );
        }

        scheduleNextScan();
      }, currentInterval);
    };

    // Start the scanning cycle
    scheduleNextScan();
  }

  private bumpNavigationSettle(): void {
    this.settleForDelay(CONFIG.SPA_SETTLE_DELAY_MS);
  }

  private settleForDelay(delayMs: number): void {
    if (!this.enabled) {
      return;
    }

    const nextPauseUntil = Date.now() + delayMs;
    this.pauseUntilMs = Math.max(this.pauseUntilMs, nextPauseUntil);
    this.needsRescan = true;

    clearTimeout(this.navigationSettleTimeout);
    const scheduleDelayMs = Math.max(0, this.pauseUntilMs - Date.now());
    this.navigationSettleTimeout = window.setTimeout(
      () => this.runNavigationSettleScan(),
      scheduleDelayMs
    );
  }

  private runNavigationSettleScan(): void {
    if (!this.enabled) {
      return;
    }

    if (Date.now() < this.pauseUntilMs) {
      const delayMs = Math.max(0, this.pauseUntilMs - Date.now());
      clearTimeout(this.navigationSettleTimeout);
      this.navigationSettleTimeout = window.setTimeout(
        () => this.runNavigationSettleScan(),
        delayMs
      );
      return;
    }

    this.scanAndHighlight();
    this.setupPeriodicScan();
  }

  private scanAndHighlight(): void {
    if (this.isProcessing) {
      return;
    }

    this.isProcessing = true;

    try {
      const result = this.domScanner.scanAndHighlight(false, this.pauseUntilMs);
      if (result.needsRescan) {
        this.needsRescan = true;
      }
    } finally {
      this.isProcessing = false;
      this.checkNeedsRescan();
    }
  }

  private checkNeedsRescan(): void {
    if (this.needsRescan) {
      this.needsRescan = false;
      // Schedule rescan with debounce to avoid tight loops
      const delayMs = Math.max(
        this.mutationDebounceMs,
        Math.max(0, this.pauseUntilMs - Date.now())
      );
      window.setTimeout(() => {
        this.scanAndHighlight();
      }, delayMs);
    }
  }

  private observePageChanges(): void {
    const observer = new MutationObserver((mutations) => {
      if (!this.enabled) {
        return;
      }

      // Detect mutation storm - if detected, increase debounce significantly
      const isStorm = this.domScanner.detectMutationStorm();

      if (Date.now() < this.pauseUntilMs) {
        this.needsRescan = true;
        this.bumpNavigationSettle();
        return;
      }

      // If currently processing, flag for rescan instead of dropping mutations
      if (this.isProcessing) {
        this.needsRescan = true;
        return;
      }

      // During a storm, skip collecting more mutations and just wait
      if (
        isStorm &&
        this.domScanner.getPendingMutations().length >
          CONFIG.MAX_PENDING_MUTATIONS
      ) {
        this.needsRescan = true;
        return;
      }

      // Collect mutations and debounce processing with adaptive timing
      this.domScanner.addPendingMutations(mutations);

      clearTimeout(this.mutationDebounceTimeout);
      this.mutationDebounceTimeout = window.setTimeout(() => {
        this.processPendingMutations();
      }, this.domScanner.getAdaptiveDebounceMs());
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
  }

  private processPendingMutations(): void {
    const pendingMutations = this.domScanner.getPendingMutations();

    if (!this.enabled || this.isProcessing || pendingMutations.length === 0) {
      this.domScanner.clearPendingMutations();
      return;
    }
    if (Date.now() < this.pauseUntilMs) {
      this.needsRescan = true;
      this.bumpNavigationSettle();
      this.domScanner.clearPendingMutations();
      return;
    }

    this.isProcessing = true;

    try {
      const mutations = [...pendingMutations];
      this.domScanner.clearPendingMutations();

      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.TEXT_NODE) {
              const textNode = node as Text;
              const parent = textNode.parentElement;

              // Skip editable areas
              if (parent && this.domScanner.isEditableElement(parent)) {
                return;
              }

              if (
                this.domScanner.hasMatchingPattern(textNode.textContent || '')
              ) {
                this.domScanner.highlightCVEsInNode(textNode);
              }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node as HTMLElement;

              // Skip our own elements and editable areas
              if (
                element.classList.contains('vulners-highlight') ||
                element.classList.contains('vulners-tooltip') ||
                this.domScanner.isEditableElement(element)
              ) {
                return;
              }

              this.domScanner.scanElementForCVEs(element);
            }
          });
        }
      }

      // Schedule batched DOM updates
      if (this.domScanner.getPendingHighlightsCount() > 0) {
        this.domScanner.scheduleHighlightFlush();
      }
    } finally {
      this.isProcessing = false;
      this.checkNeedsRescan();
    }
  }
}
